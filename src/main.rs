use std::{
    fs,
    io::{self, BufRead, BufReader, Read},
    path::{Path, PathBuf},
    process::ExitCode,
};

use clap::Parser;
use msf_hasher::{Algorithm, Hasher};

#[derive(Clone, Debug, PartialEq, Eq, Parser)]
#[command(about, version)]
#[clap(disable_help_flag = true)]
#[allow(clippy::struct_excessive_bools)]
/// A simple *sum program with support of SHA1, SHA256, SHA512, MD5 algorithms.
struct Args {
    #[arg(short, long, default_value_t)]
    /// Change the hash algorithm from SHA256 (default) to one of [MD5, SHA1, SHA512].
    /// Used in conjunction with --check if non-default hash algorithm was used.
    pub hash: Algorithm,

    #[arg(short, long)]
    /// Read sums using the provided algorithm from the FILEs and check them.
    pub check: bool,

    #[arg(long)]
    /// Exit non-zero for improperly formatted checksum lines.
    pub strict: bool,

    #[arg(long)]
    /// Warn about improperly formatted checksum lines.
    pub warn: bool,

    #[arg(long)]
    /// Don't print OK for each successfully verified file.
    pub quiet: bool,

    #[arg(long)]
    /// Donâ€™t fail or report status for missing files.
    pub ignore_missing: bool,

    // Unfortunatelly, `-h` for hash and `-h` for help collide and result in panic in runtime.
    // This is a workaround to override default helping arguments generated by `clap`
    #[arg(long, action = clap::ArgAction::HelpLong)]
    /// Display this message and exit.
    help: Option<bool>,

    /// A list of files to hash with the provided algorithm.
    ///
    /// Note that if none were supplied, standart input stream will be used.
    /// Additionally, "-" is an alias for the standart input stream
    files: Vec<PathBuf>,
}

impl Args {
    /// Validates CLI-argument
    ///
    /// The only invariant by far that *must* be uphold is:
    /// * If no files were provided, read from standard input
    pub fn validate(mut self) -> Self {
        if self.files.is_empty() {
            self.files.push(PathBuf::from("-"));
        }
        self
    }

    /// Tries to open a file at the given path
    ///
    /// This function is aware of the configuration, and will log an error if
    /// the file doesn't exist and if the `--ignore-missing` argument is set
    pub fn try_open_file<P: AsRef<Path>>(&self, path: P) -> io::Result<fs::File> {
        let path = path.as_ref();
        match fs::File::open(path) {
            val @ Ok(_) => val,
            err => {
                if !self.ignore_missing {
                    eprintln!("Error: failed to open {path:?}");
                }
                err
            }
        }
    }

    /// Tries to read a file at the given path to string
    ///
    /// This function is aware of the configuration, and will log an error if
    /// the file doesn't exist and if the `--ignore-missing` argument is set
    pub fn try_read_to_string<P: AsRef<Path>>(&self, path: P) -> io::Result<String> {
        let path = path.as_ref();
        match fs::read_to_string(path) {
            value @ Ok(_) => value,
            err => {
                if !self.ignore_missing {
                    eprintln!("Error: failed to open {path:?}");
                }
                err
            }
        }
    }
}

fn hash_single<T>(hasher: &mut Hasher, mut reader: BufReader<T>, path: &Path, buf: &mut Vec<u8>)
where
    T: Read,
{
    if let Err(e) = reader.read_to_end(buf) {
        // This should log regardless of the `--ignore-missing` argument
        // as the file was already opened, and now we are having troubles reading it.
        // Though it's unlikely to fail.
        eprintln!("Error reading {path:?}: {e:?}");
        return;
    }

    let hash = hasher.hash(&buf);
    println!("{}  {}", hash, path.display());
}

/// Computes and prints the hashes of the provided files
fn hash(args: &Args, hasher: &mut Hasher) {
    let mut buf = Vec::new();

    for path in &args.files {
        if let Some("-") = path.to_str() {
            hash_single(hasher, BufReader::new(io::stdin()), path, &mut buf);
        } else {
            let Ok(file) = args.try_open_file(path) else {
                continue;
            };

            hash_single(hasher, BufReader::new(file), path, &mut buf);
        }

        buf.truncate(0); // Reset the buffer. This sets `length` to 0, so the next iteration will overwrite the data
    }
}

fn check_single<T>(
    args: &Args,
    hasher: &mut Hasher,
    reader: BufReader<T>,
    path: &Path,
    exit_code: &mut ExitCode,
) -> usize
where
    T: Read,
{
    let mut proper_lines = 0;
    // Reading all lines in the supplied files
    for (index, line) in reader.lines().enumerate() {
        let line = line.unwrap();

        // Splitting checksum and the filename
        let Some((checksum, file)) = line.split_once(' ') else {
            if args.warn {
                eprintln!(
                    "Improperly formatted line at \"{}:{}\"",
                    path.display(),
                    index + 1
                );
            }
            if args.strict {
                *exit_code = ExitCode::FAILURE;
            }
            continue;
        };
        proper_lines += 1;

        let file = file.trim_start(); // It may be one or two spaces after hash in checksum file

        let Ok(data) = args.try_read_to_string(file) else {
            continue;
        };

        match (hasher.verify(&data, checksum), args.quiet) {
            (true, false) => println!("{file}: OK"),
            (false, _) => println!("{file}: FAILED"),
            _ => (),
        }
    }
    proper_lines
}

/// Verifies checksums of the provided files
///
/// Note that the `exit_code` parameter will be set to `ExitCode::FAILURE` if any
/// of the provided files contains an improperly formatted line and
/// if the `Args::strict` argument is set
fn check_all(args: &Args, hasher: &mut Hasher, exit_code: &mut ExitCode) {
    let mut proper_lines = 0;
    for path in &args.files {
        if let Some("-") = path.to_str() {
            proper_lines +=
                check_single(args, hasher, BufReader::new(io::stdin()), path, exit_code);
        } else {
            let Ok(file) = args.try_open_file(path) else {
                continue;
            };
            proper_lines += check_single(args, hasher, BufReader::new(file), path, exit_code);
        }
    }

    // `sha256sum` also exits with 1 if `--strict` is set and no proper lines were scanned
    if proper_lines == 0 && args.strict {
        *exit_code = ExitCode::FAILURE;
    }
}

fn main() -> ExitCode {
    let args = Args::parse().validate();
    let mut hasher = Hasher::from_algorithm(args.hash);

    let mut exit_code = ExitCode::SUCCESS;

    if args.check {
        check_all(&args, &mut hasher, &mut exit_code);
    } else {
        hash(&args, &mut hasher);
    }

    exit_code
}
