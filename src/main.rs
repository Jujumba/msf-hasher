use msf_hasher::{Algorithm, Hasher};

use clap::Parser;
use std::{
    fs,
    io::{self, BufRead, BufReader, Read},
    path::{Path, PathBuf},
    process::ExitCode,
};

#[derive(Clone, Debug, PartialEq, Eq, Parser)]
#[command(about, version)]
#[clap(disable_help_flag = true)]
struct Args {
    #[arg(short, long, default_value_t)]
    /// Change the hash algorithm from SHA256 (default) to one of [MD5,SHA1,SHA512].
    /// Used in conjunction with --check if non-default hash algorithm was used.
    pub hash: Algorithm,

    #[arg(short, long)]
    // todo: describe how checksum file looks like
    /// Read sums using the provided algorithm from the FILEs and check them.
    pub check: bool,

    #[arg(long)]
    /// Exit non-zero for improperly formatted checksum lines.
    pub strict: bool,

    #[arg(long)]
    /// Warn about improperly formatted checksum lines.
    pub warn: bool,

    #[arg(long)]
    /// Don't print OK for each successfully verified file.
    pub quiet: bool,

    #[arg(long)]
    /// Donâ€™t fail or report status for missing files.
    pub ignore_missing: bool,

    // Unfortunatelly, `-h` for hash and `-h` for help collide and result in panic in runtime.
    // This is a workaround to override default helping arguments generated by `clap`
    #[arg(long, action = clap::ArgAction::HelpLong)]
    /// Display this message and exit.
    help: Option<bool>,

    /// A list of files to hash with the provided algorithm.
    ///
    /// Note that if none were supplied, standart input stream will be used.
    /// Additionally, "-" is an alias for the standart input stream
    files: Vec<PathBuf>,
}

type Reader = BufReader<Box<dyn Read>>;

impl Args {
    pub fn validate(mut self) -> Self {
        if self.files.is_empty() {
            self.files.push(PathBuf::from("-"));
        }
        self
    }
    pub fn readers(&self) -> Vec<Reader> {
        self.files
            .iter()
            .filter_map(|path| self.open_file(&path))
            .collect()
    }
    pub fn pathes(&self) -> impl Iterator<Item = &Path> {
        self.files.iter().map(|path| path.as_path())
    }
    fn open_file(&self, path: &Path) -> Option<Reader> {
        // Check if the path matches our `stdin` definition
        match path.to_str().unwrap() {
            "" | "-" => return Some(self.open_stdin()),
            _ => (),
        }

        // Otherwise it's a "regular" file
        let file = fs::File::open(path);
        match file {
            Ok(file) => Some(BufReader::new(Box::new(file))),
            Err(e) if !self.ignore_missing => {
                eprintln!("Error opening {path:?}: {e:?}");
                None
            }
            _ => None,
        }
    }
    fn open_stdin(&self) -> Reader {
        BufReader::new(Box::new(io::stdin()))
    }
}

fn hash(args: Args, mut hasher: Hasher) {
    let mut buf = Vec::new();
    for (path, mut reader) in args.pathes().zip(args.readers()) {
        match reader.read_to_end(&mut buf) {
            Err(e) => {
                eprintln!("Error reading {path:?}: {e:?}");
                continue;
            }
            _ => (),
        }

        let hash = hasher.hash(&buf);
        println!("{}  {}", hash, path.display());

        buf.truncate(0); // Reset the buffer. This sets `length` to 0, so the next iteration will overwrite the data
    }
}
fn check(args: Args, mut hasher: Hasher, exit_code: &mut ExitCode) {
    for (path, reader) in args.pathes().zip(args.readers()) {
        for (index, line) in reader.lines().into_iter().enumerate() {
            let line = line.unwrap();

            let Some((checksum, file)) = line.split_once(' ') else {
                if args.warn {
                    eprintln!("Improperly formatted line at {}:{}", path.display(), index);
                }
                if args.strict {
                    *exit_code = ExitCode::FAILURE;
                }
                continue;
            };

            let data = match fs::read_to_string(&file) {
                Ok(data) => data,
                Err(_) if !args.ignore_missing => {
                    eprintln!("Error: failed to open {file:?}");
                    continue;
                }
                _ => continue,
            };

            match (hasher.verify(checksum, &data), args.quiet) {
                (true, false) => println!("{file}: OK"),
                (false, _) => println!("{file}: FAILED"),
                _ => (),
            }
        }
    }
}

fn main() -> ExitCode {
    let args = Args::parse().validate();
    let hasher = Hasher::from_algorithm(args.hash);

    let mut exit_code = ExitCode::SUCCESS;

    if args.check {
        check(args, hasher, &mut exit_code);
    } else {
        hash(args, hasher);
    }

    exit_code
}
